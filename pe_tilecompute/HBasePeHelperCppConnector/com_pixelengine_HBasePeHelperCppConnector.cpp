/* DO NOT EDIT THIS FILE - it is machine generated */
#include "com_pixelengine_HBasePeHelperCppConnector.h"

#include <string>
#include <vector>
#include <iostream>
#include "lodepng.h"
#include "PixelEngine.h"
#include <random>
#include "../JavaPixelEngineHelperInterface.h"
#include "../wDatasetDatetime.h"
#include "spdlog/spdlog.h"
#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/sinks/basic_file_sink.h"
#include "../ajson5.h"
#include "PeStyle.h"
#include <sstream>
#include "whsegtlvobject.h"//2022-3-23
#include "jnihelpertools.h"//2022-9-28

using namespace std;
using namespace ArduinoJson;

/// 这个文件下的全局函数是对应Java中CppConnector类的成员函数
/// Java主动调用的。


//connector版本信息
//string global_connector_version_str = "connector_version:0.2.0 2020-12-02" ;

//2021-1-21 增加两个java调用c++接口，用于传入extra的json字符串
//Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithoutRenderWithExtra
//Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithRenderWithExtra
//string global_connector_version_str = "connector_version:0.3.1 2021-01-21" ;

//2022-2-12 增加获取脚本全部数据集名称的接口
//(1)Java_com_pixelengine_HBasePeHelperCppConnector_GetDatasetNameArray
//string global_connector_version_str = "connector_version:1.0.0 2022-02-12" ;

//2022-3-6 rebuild with new core
//string global_connector_version_str = "connector_version:1.0.1 2022-03-06" ;

//2022-3-22 增加1个接口，执行瓦片计算并获取执行后的 (dsname,dt)，roi2，log
//string global_connector_version_str = "connector_version:1.1.0 2022-03-22" ;

//2022-3-23 增加1个接口，计算hsegtlv的四角范围
//string global_connector_version_str = "connector_version:1.2.0 2022-03-23" ;

//2022-3-23 增加1个接口，直接使用hsegtlv裁剪TileComputeResult
//string global_connector_version_str = "connector_version:1.3.0 2022-03-23" ;

//2022-3-26 增加1个接口，直接计算TileComputeResult统计结果
//string global_connector_version_str = "connector_version:1.4.1r 2022-03-26" ;

//2022-7-3 pe.log 结果写入 TileComputeResult
//string global_connector_version_str = "connector_version:1.5.1 2022-07-03" ;

//2022-7-17 增加 RunScriptForTextResultWithExtra
//string global_connector_version_str = "connector_version:1.6.0 2022-07-17" ;

//2022-9-7 增加 RunScriptFunctionForTileResult
//string global_connector_version_str = "connector_version:1.7.0 2022-09-07" ;

//2022-9-9 增加 RunScriptFunctionForTextResultOrNothing
//string global_connector_version_str = "connector_version:1.8.0 2022-09-09" ;

//2022-9-27 增加 瓦片结果直接计算png二进制流
//add ConvertRgbaData2PngBinary
//add RenderTileData2Rgba
//add ClipBinaryTileData
string global_connector_version_str = "connector_version:1.9.4" ;

//外部调用，获得connector和core版本信息
extern "C" void HBasePeHelperCppConnector_GetVersion(){
    PixelEngine pe;
    string ver  = global_connector_version_str+";core_version:" + pe.GetVersion() ;
    cout<<ver<<endl ;
}



jstring cstring2jstring(JNIEnv *env,
	const char* str) {
	return env->NewStringUTF(str) ;
}




/*
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    GetVersion
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_GetVersion
  (JNIEnv * env, jobject object)
{//这个方法是给java调用的
	PixelEngine pe;
	string ver  = global_connector_version_str+";core_version:" + pe.GetVersion() ;
	return JavaPixelEngineHelperInterface::cstring2jstring(env, ver.c_str()) ;
}

/*
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    RunToGetStyleFromScript
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 * return json string of Style
 */
JNIEXPORT jstring JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_RunToGetStyleFromScript
  (JNIEnv * env, jobject object, jstring javaPEHelperClassName, jstring scriptContent)
{
	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_RunToGetStyleFromScript\n");
	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;

	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;

	string cscriptContent = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;

	string logtext ;
	pe::PeStyle retStyle;

	bool isok = pe.RunToGetStyleFromScript(cscriptContent, retStyle ,logtext);
	if( isok ){
		string stylejson = retStyle.toJson() ;
		return JavaPixelEngineHelperInterface::cstring2jstring(env,stylejson.c_str() );
	}else {
		printf("Error : failed to get style from script. %s\n" , logtext.c_str() ) ;
		return JavaPixelEngineHelperInterface::cstring2jstring(env, "" ) ;
	}
}



/*
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    ParseScriptForDsDt
 * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
{
	"dsdtarr":[] ,
	"error":"",
	"status":0   //0 for good, 1 for error
}

 */
JNIEXPORT jstring JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_ParseScriptForDsDt
  (JNIEnv * env, jobject object ,
  	jstring javaPEHelperClassName,
  	jstring scriptContent )
{
	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_ParseScriptForDsDt()\n") ;

	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;

	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;

	string cscriptContent = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;

	vector<wDatasetDatetime> retdsdtvec;
	string errorText;
	bool ok = pe.RunScriptForDatasetDatetimePairs( nullptr ,
		cscriptContent,
		retdsdtvec ,
		errorText) ;
	DynamicJsonBuffer jsonBuffer;
	JsonObject& root = jsonBuffer.createObject();
	if( ok ){
		root["status"] = 0 ;//ok
		root["error"] = "" ;
		JsonArray& dsdtarr = root.createNestedArray("dsdtarr") ;
		for(int ids = 0 ; ids < retdsdtvec.size(); ++ ids ){
			JsonObject& dobj = dsdtarr.createNestedObject() ;
			dobj["ds"] = retdsdtvec[ids].ds ;
			dobj["dt0"] = retdsdtvec[ids].dt0 ;
			dobj["dt1"] = retdsdtvec[ids].dt1 ;
		}
	}else{
		root["status"] = 1 ;
		root["error"] = errorText ;
		//root["dsdtarr"]
		root.createNestedArray("dsdtarr") ;
	}

	string jsonstr ;
	root.printTo(jsonstr) ;
	jstring jstr = JavaPixelEngineHelperInterface::cstring2jstring(env, jsonstr.c_str() ) ;
	return jstr ;
}



/* 2022-2-12 获取脚本中全部数据集名称,返回结果是Json格式字符串{status:0,error:"",data:[...]}
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    GetDatasetNameArray
 * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
 * {
	"data":["fy4","fy3","modis/ndvi","ls/08"] ,
	"error":"",
	"status":0   //0 for good, 1 for error
    }
 */
JNIEXPORT jstring JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_GetDatasetNameArray
  (JNIEnv * env, jobject object ,
  	jstring javaPEHelperClassName,
  	jstring scriptContent)
{
    printf("in Java_com_pixelengine_HBasePeHelperCppConnector_GetDatasetNameArray()\n") ;

	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;
	PixelEngine pe ;
	string cscriptContent = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;

	vector<string> retDsNameArr ;
	string errorText;
	bool ok = pe.GetDatasetNameArray( nullptr ,
		cscriptContent,
		retDsNameArr ,
		errorText) ;
	DynamicJsonBuffer jsonBuffer;
	JsonObject& root = jsonBuffer.createObject();
	if( ok ){
		root["status"] = 0 ;//ok
		root["error"] = "" ;
		JsonArray& jdsNameArr = root.createNestedArray("data") ;
		for(int ids = 0 ; ids < retDsNameArr.size(); ++ ids ){
            jdsNameArr.add(retDsNameArr[ids]) ;
		}
	}else{
		root["status"] = 9 ;
		root["error"] = errorText ;
		root.createNestedArray("data") ;
	}
	string jsonstr ;
	root.printTo(jsonstr) ;
	jstring jstr = JavaPixelEngineHelperInterface::cstring2jstring(env, jsonstr.c_str() ) ;
	return jstr ;
}





/*
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    RunScriptForTileWithoutRender
 * Signature: (Ljava/lang/String;Ljava/lang/String;JIII)Lcom/pixelengine/TileComputeResult;

 */
JNIEXPORT jobject JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithoutRender
  (JNIEnv * env, jobject object,
  	jstring javaPEHelperClassName,
  	jstring scriptContent,
  	jlong datetime,
  	jint z, jint y, jint x)
{

	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithoutRender()\n") ;
	jclass	javaTileComputeResultClass = (env)->FindClass("com/pixelengine/TileComputeResult");
	if( javaTileComputeResultClass == NULL )
	{
		printf("Error : not find class of com/pixelengine/TileComputeResult.");
		return NULL ;
	}
	jobject	javaResult = env->AllocObject(javaTileComputeResultClass);

	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;

	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;

	string cscript = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;
	PeTileData retTileData;
	string logStr;

	bool runok = pe.RunScriptForTileWithoutRender(nullptr,
		cscript ,
		datetime ,
		z , y , x ,
		retTileData ,
		logStr ) ;

	if( runok == false ){
		cout<<"run script failed : "<<logStr<<endl;

		helper.setJavaObjectIntField(javaResult,"status",1) ;//status=1 bad.
		// helper.setJavaObjectStringField(javaResult,"log",logStr.c_str()) ;
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() )  ;//2022-7-3

	}else{
		cout<<"run script ok."<<endl ;
		helper.setJavaObjectIntField(javaResult,"status",0) ;//status=0 ok.
		helper.setJavaObjectIntField(javaResult,"outType", 0) ;//0-dataset, 1-png
		helper.setJavaObjectIntField(javaResult,"dataType", retTileData.dataType ) ;
		helper.setJavaObjectIntField(javaResult,"width",  retTileData.width ) ;
		helper.setJavaObjectIntField(javaResult,"height", retTileData.height ) ;
		helper.setJavaObjectIntField(javaResult,"nbands", retTileData.nbands ) ;
		helper.setJavaObjectByteArrField(javaResult,"binaryData", retTileData.tiledata ) ;
		helper.setJavaObjectIntField(javaResult,"z", z) ;
		helper.setJavaObjectIntField(javaResult,"y", y) ;
		helper.setJavaObjectIntField(javaResult,"x", x) ;
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() )  ;//2022-7-3
	}
	return javaResult ;
}


/*
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    RunScriptForTileWithRender
 * Signature: (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;JIII)Lcom/pixelengine/TileComputeResult;
 */
JNIEXPORT jobject JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithRender
  (JNIEnv * env , jobject object ,
  	jstring javaPEHelperClassName,
  	jstring scriptContent,
  	jstring styleJson,
  	jlong datetime ,
  	jint z,
  	jint y,
  	jint x
  	)
{
	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithRender()\n") ;
	jclass	javaTileComputeResultClass = (env)->FindClass("com/pixelengine/TileComputeResult");
	if( javaTileComputeResultClass == NULL )
	{
		printf("Error : not find class of com/pixelengine/TileComputeResult.");
		return NULL ;
	}

	jobject	javaResult = env->AllocObject(javaTileComputeResultClass);

	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;

	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;
	string cscript = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;
	string cstyle = JavaPixelEngineHelperInterface::jstring2cstring(env,styleJson) ;

	pe::PeStyle tstyle ;
	bool styleok = tstyle.loadFromJson(cstyle) ;
	if( styleok ){

	}else{
		printf("Warning : bad style from json.\n") ;
	}
	vector<unsigned char> retPngBinary ;
	string logStr;
	int pngwid=0;
	int pnghei=0;

	bool runok = pe.RunScriptForTileWithRender(nullptr,
			cscript ,
			tstyle,
			(int64_t)datetime ,
			z , y , x ,
			retPngBinary ,
			pngwid,
			pnghei,
			logStr ) ;

	if( runok ){
		cout<<"run script ok."<<endl ;
		helper.setJavaObjectIntField(javaResult,"status",0) ;//status=0 ok.
		helper.setJavaObjectIntField(javaResult,"outType", 1) ;//0-dataset, 1-png
		helper.setJavaObjectIntField(javaResult,"dataType", 1 ) ;//useful ?
		helper.setJavaObjectIntField(javaResult,"width",  pngwid ) ;
		helper.setJavaObjectIntField(javaResult,"height", pnghei ) ;
		helper.setJavaObjectIntField(javaResult,"nbands", 4 ) ;//useful ?
		helper.setJavaObjectByteArrField(javaResult,"binaryData", retPngBinary) ;
		helper.setJavaObjectIntField(javaResult,"z", z) ;
		helper.setJavaObjectIntField(javaResult,"y", y) ;
		helper.setJavaObjectIntField(javaResult,"x", x) ;
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() )  ;//2022-7-3
		return javaResult;
	}else{
		printf("Error : failed to pe.RunScriptForTileWithRender.\n") ;
		helper.setJavaObjectIntField(javaResult,"status",1) ;//status=1 bad.
		// helper.setJavaObjectStringField(javaResult,"log",logStr.c_str()) ;
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() )  ;//2022-7-3
		return javaResult ;
	}
}


/*
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    RunScriptForTileWithoutRenderWithExtra
 * Signature: (Ljava/lang/String;Ljava/lang/String;JLjava/lang/String;III)Lcom/pixelengine/TileComputeResult;
 */
JNIEXPORT jobject JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithoutRenderWithExtra
  (JNIEnv * env, jobject object,
  	jstring javaPEHelperClassName,
  	jstring scriptContent,
    jstring extraJsonText,
  	jint z, jint y, jint x)
{

	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithoutRender()\n") ;
	jclass	javaTileComputeResultClass = (env)->FindClass("com/pixelengine/TileComputeResult");
	if( javaTileComputeResultClass == NULL )
	{
		printf("Error : not find class of com/pixelengine/TileComputeResult.");
		return NULL ;
	}
	jobject	javaResult = env->AllocObject(javaTileComputeResultClass);

	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;

	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;

	string cscript = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;
    string cExJsonText = JavaPixelEngineHelperInterface::jstring2cstring(env,extraJsonText) ;

	PeTileData retTileData;
	string logStr;

	bool runok = pe.RunScriptForTileWithoutRenderWithExtra(
        nullptr,
		cscript ,
        cExJsonText,
		z , y , x ,
		retTileData ,
		logStr ) ;

	if( runok == false ){
		cout<<"run script failed : "<<logStr<<endl;

		helper.setJavaObjectIntField(javaResult,"status",1) ;//status=1 bad.
		//helper.setJavaObjectStringField(javaResult,"log",logStr.c_str()) ;
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() )  ;//2022-7-3
	}else{
		cout<<"run script ok."<<endl ;
		helper.setJavaObjectIntField(javaResult,"status",0) ;//status=0 ok.
		helper.setJavaObjectIntField(javaResult,"outType", 0) ;//0-dataset, 1-png
		helper.setJavaObjectIntField(javaResult,"dataType", retTileData.dataType ) ;
		helper.setJavaObjectIntField(javaResult,"width",  retTileData.width ) ;
		helper.setJavaObjectIntField(javaResult,"height", retTileData.height ) ;
		helper.setJavaObjectIntField(javaResult,"nbands", retTileData.nbands ) ;
		helper.setJavaObjectByteArrField(javaResult,"binaryData", retTileData.tiledata ) ;
		helper.setJavaObjectIntField(javaResult,"z", z) ;
		helper.setJavaObjectIntField(javaResult,"y", y) ;
		helper.setJavaObjectIntField(javaResult,"x", x) ;
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() )  ;//2022-7-3
	}
	return javaResult ;
}


/* 2022-9-7
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    RunScriptFunctionForTileResult
 * Signature: (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;III)Lcom/pixelengine/TileComputeResult;
 */
JNIEXPORT jobject JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptFunctionForTileResult
(
	JNIEnv * env, 
	jobject object,
	jstring javaPEHelperClassName,
	jstring scriptContent,
	jstring caller,
	jint z, jint y, jint x
)
{
	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptFunctionForTileResult()\n") ;
	jclass	javaTileComputeResultClass = (env)->FindClass("com/pixelengine/TileComputeResult");
	if( javaTileComputeResultClass == NULL )
	{
		printf("Error : not find class of com/pixelengine/TileComputeResult.");
		return NULL ;
	}
	jobject	javaResult = env->AllocObject(javaTileComputeResultClass);
	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;
	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;
	string cscript = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;
	string ccaller = JavaPixelEngineHelperInterface::jstring2cstring(env,caller) ;
	PeTileData retTileData;
	bool runok = pe.RunScriptFunctionForTileResult(
		cscript ,
    ccaller,
		z , y , x ,
		retTileData ) ;
	if( runok == false ){
		cout<<"run script failed : "<<pe.GetPeLogs()<<endl;
		helper.setJavaObjectIntField(javaResult,"status",1) ;//status=1 bad.
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() )  ;//2022-7-3
	}else{
		cout<<"run script ok."<<endl ;
		helper.setJavaObjectIntField(javaResult,"status",0) ;//status=0 ok.
		helper.setJavaObjectIntField(javaResult,"outType", 0) ;//0-dataset, 1-png
		helper.setJavaObjectIntField(javaResult,"dataType", retTileData.dataType ) ;
		helper.setJavaObjectIntField(javaResult,"width",  retTileData.width ) ;
		helper.setJavaObjectIntField(javaResult,"height", retTileData.height ) ;
		helper.setJavaObjectIntField(javaResult,"nbands", retTileData.nbands ) ;
		helper.setJavaObjectByteArrField(javaResult,"binaryData", retTileData.tiledata ) ;
		helper.setJavaObjectIntField(javaResult,"z", z) ;
		helper.setJavaObjectIntField(javaResult,"y", y) ;
		helper.setJavaObjectIntField(javaResult,"x", x) ;
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() )  ;//2022-7-3
	}
	return javaResult ;
}


//2022-9-9
JNIEXPORT jstring JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptFunctionForTextResultOrNothing
(
	JNIEnv * env, 
	jobject object,
	jstring javaPEHelperClassName,
	jstring scriptContent,
	jstring caller,
	jint z, jint y, jint x
)
{
	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptFunctionForTextResultOrNothing()\n") ;
	
	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;
	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;
	string cscript = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;
	string ccaller = JavaPixelEngineHelperInterface::jstring2cstring(env,caller) ;
	string res0 ;
	bool runok = pe.RunScriptFunctionForTextResultOrNothing(
		cscript ,
    ccaller,
		z , y , x ,
		res0 ) ;
	string res1 ;
	if( runok == false ){
		cout<<"run script failed : "<<pe.GetPeLogs()<<endl;
		res1 = string(";;;log;;;") + pe.GetPeLogs();
	}else{
		cout<<"run script ok."<<endl ;
		res1 = res0 + string(";;;log;;;") + pe.GetPeLogs();
	}
	return JavaPixelEngineHelperInterface::cstring2jstring(env,res1.c_str()) ;
}


/* 2022-3-22 增加返回dsname,dt roi2 和 log信息到 TileComputeResultWithRunAfterInfo 里面
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    RunScriptForTileWithoutRenderWithExtraWithRunAfterInfo
 * Signature: (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;III)Lcom/pixelengine/TileComputeResultWithRunAfterInfo;
 */
JNIEXPORT jobject JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithoutRenderWithExtraWithRunAfterInfo
  (
  	JNIEnv * env, jobject object,
  	jstring javaPEHelperClassName,
  	jstring scriptContent,
    jstring extraJsonText,
  	jint z, jint y, jint x
  	)
{
	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithoutRenderWithExtraWithRunAfterInfo()\n") ;
	jclass	javaTileComputeResultClass = (env)->FindClass("com/pixelengine/TileComputeResultWithRunAfterInfo");
	if( javaTileComputeResultClass == NULL )
	{
		printf("Error : not find class of com/pixelengine/TileComputeResultWithRunAfterInfo.");
		return NULL ;
	}
	jobject	javaResult = env->AllocObject(javaTileComputeResultClass);

	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;

	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;

	string cscript = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;
  string cExJsonText = JavaPixelEngineHelperInterface::jstring2cstring(env,extraJsonText) ;

	PeTileData retTileData;
	string logStr;

	bool runok = pe.RunScriptForTileWithoutRenderWithExtra(
        nullptr,
		cscript ,
        cExJsonText,
		z , y , x ,
		retTileData ,
		logStr ) ;

	if( runok == false ){
		cout<<"run script failed : "<<logStr<<endl;

		helper.setJavaObjectIntField(javaResult,"status",1) ;//status=1 bad.
		//helper.setJavaObjectStringField(javaResult,"log",logStr.c_str()) ;
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() ) ;//2022-7-3
		
	}else{
		cout<<"run script ok."<<endl ;
		helper.setJavaObjectIntField(javaResult,"status",0) ;//status=0 ok.
		helper.setJavaObjectIntField(javaResult,"outType", 0) ;//0-dataset, 1-png
		helper.setJavaObjectIntField(javaResult,"dataType", retTileData.dataType ) ;
		helper.setJavaObjectIntField(javaResult,"width",  retTileData.width ) ;
		helper.setJavaObjectIntField(javaResult,"height", retTileData.height ) ;
		helper.setJavaObjectIntField(javaResult,"nbands", retTileData.nbands ) ;
		helper.setJavaObjectByteArrField(javaResult,"binaryData", retTileData.tiledata ) ;
		helper.setJavaObjectIntField(javaResult,"z", z) ;
		helper.setJavaObjectIntField(javaResult,"y", y) ;
		helper.setJavaObjectIntField(javaResult,"x", x) ;
		//2022-3-22
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() ) ;
		vector<string> dsnamedtArr = pe.GetDsnameDtVec() ;
		vector<string> roi2Arr = pe.GetRoi2Vec() ;
		string dsdtstr , roi2str ;
		for(int iii = 0 ; iii < dsnamedtArr.size() ; ++ iii ) dsdtstr=dsdtstr+dsnamedtArr[iii]+";" ;
		for(int iii = 0 ; iii < roi2Arr.size()     ; ++ iii ) roi2str=roi2str+roi2Arr[iii] + ";" ;
		helper.setJavaObjectStringField(javaResult,"dsnameDtArrStr", dsdtstr.c_str() ) ;
		helper.setJavaObjectStringField(javaResult,"roi2ArrStr",     roi2str.c_str() ) ;

	}
	return javaResult ;


}

/* 2022-7-17 计算main函数的文本结果，基于pe的代码，需要v8
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    RunScriptForTextResultWithExtra
 * Signature: (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTextResultWithExtra
(
JNIEnv * env, jobject object,
	jstring javaPEHelperClassName,
	jstring scriptContent,
  jstring extraJsonText
	)
{
	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTextResultWithExtra()\n") ;
	
	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;
	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;
	string cscript = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;
  string cExJsonText = JavaPixelEngineHelperInterface::jstring2cstring(env,extraJsonText) ;
	string resultStr;
	string logStr;
	bool runok = pe.RunScriptForTextResultWithExtra(
        nullptr,
				cscript ,
        cExJsonText,
				resultStr,
				logStr ) ;

	if( runok == false ){
		cout<<"run script failed : "<<logStr<<endl;		
	}
	jstring jstr = 
		JavaPixelEngineHelperInterface::cstring2jstring(env, resultStr.c_str() ) ;
	return jstr ;
}















/*
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    RunScriptForTileWithRenderWithExtra
 * Signature: (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;III)Lcom/pixelengine/TileComputeResult;
 */
JNIEXPORT jobject JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithRenderWithExtra
  (JNIEnv * env , jobject object ,
  	jstring javaPEHelperClassName,
  	jstring scriptContent,
  	jstring styleJson,
    jstring extraJsonText,
  	jint z,
  	jint y,
  	jint x
  	)
{
	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithRender()\n") ;
	jclass	javaTileComputeResultClass = (env)->FindClass("com/pixelengine/TileComputeResult");
	if( javaTileComputeResultClass == NULL )
	{
		printf("Error : not find class of com/pixelengine/TileComputeResult.");
		return NULL ;
	}

	jobject	javaResult = env->AllocObject(javaTileComputeResultClass);

	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;

	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;
	string cscript = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;
	string cstyle = JavaPixelEngineHelperInterface::jstring2cstring(env,styleJson) ;
    string cExJsonText = JavaPixelEngineHelperInterface::jstring2cstring(env,extraJsonText) ;

	pe::PeStyle tstyle ;
	bool styleok = tstyle.loadFromJson(cstyle) ;
	if( styleok ){

	}else{
		printf("Warning : bad style from json.\n") ;
	}
	vector<unsigned char> retPngBinary ;
	string logStr;
	int pngwid=0;
	int pnghei=0;

	bool runok = pe.RunScriptForTileWithRenderWithExtra(
            nullptr,
			cscript ,
			tstyle,
            cExJsonText,
			z , y , x ,
			retPngBinary ,
			pngwid,
			pnghei,
			logStr ) ;

	if( runok ){
		cout<<"run script ok."<<endl ;
		helper.setJavaObjectIntField(javaResult,"status",0) ;//status=0 ok.
		helper.setJavaObjectIntField(javaResult,"outType", 1) ;//0-dataset, 1-png
		helper.setJavaObjectIntField(javaResult,"dataType", 1 ) ;//useful ?
		helper.setJavaObjectIntField(javaResult,"width",  pngwid ) ;
		helper.setJavaObjectIntField(javaResult,"height", pnghei ) ;
		helper.setJavaObjectIntField(javaResult,"nbands", 4 ) ;//useful ?
		helper.setJavaObjectByteArrField(javaResult,"binaryData", retPngBinary) ;
		helper.setJavaObjectIntField(javaResult,"z", z) ;
		helper.setJavaObjectIntField(javaResult,"y", y) ;
		helper.setJavaObjectIntField(javaResult,"x", x) ;
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() ) ;//2022-7-3
		return javaResult;
	}else{
		printf("Error : failed to pe.RunScriptForTileWithRender.\n") ;
		helper.setJavaObjectIntField(javaResult,"status",1) ;//status=1 bad.
		//helper.setJavaObjectStringField(javaResult,"log",logStr.c_str()) ;
		helper.setJavaObjectStringField(javaResult,"log", pe.GetPeLogs().c_str() ) ;//2022-7-3
		return javaResult ;
	}
}


/*
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    CheckScriptOk
 * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_CheckScriptOk
  (JNIEnv * env , jobject object , jstring javaPEHelperClassName, jstring scriptContent )
{
	string jsSource = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;
	if( jsSource.length() < 1 ){
		return JavaPixelEngineHelperInterface::cstring2jstring( env , "Error: source is empty." ) ;
	}else
	{
		PixelEngine::initV8() ;
		PixelEngine pe ;
		string errorinfo = pe.CheckScriptOk(jsSource) ;
		return JavaPixelEngineHelperInterface::cstring2jstring( env , errorinfo.c_str() ) ;
	}
}




/* 2022-3-23 工具方法计算hsegtlv 的level0 的四至范围，注意该范围可能略小于实际范围，可以通过向外推一个像素即可肯定完全包括。
 * 成功返回四至范围数字组成的字符串，由逗号分割，顺序如后 left,right,top,bottom
 * 失败返回空字符串
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    UtilsComputeHsegTlvExtent
 * Signature: ([B)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_UtilsComputeHsegTlvExtent
  (JNIEnv * env , jobject object, jbyteArray hsegtlvdata)
{
	jbyte* barr = (jbyte*)env->GetByteArrayElements(hsegtlvdata,0) ;
	jsize  blen = env->GetArrayLength(hsegtlvdata) ;
	//copy data
	vector<unsigned char> binarydata(blen);
	memcpy( binarydata.data() , barr , blen ) ;
	env->ReleaseByteArrayElements(hsegtlvdata,barr,0) ;

	string error ;
	//WHsegTlvObject
	WHsegTlvObject tlv ;
	bool ok1 = tlv.readFromBinaryData(binarydata,error) ;
	if( ok1==false ){
		cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_UtilsComputeHsegTlvExtent bad:"<<error<<endl ;
		return JavaPixelEngineHelperInterface::cstring2jstring( env , "" ) ;
	}else{
		double left(0),right(0),top(0),bottom(0) ;
		bool ok2 = tlv.computeExtent( left, right, top, bottom) ;
		if( ok2==false ){
			cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_UtilsComputeHsegTlvExtent bad:computeExtent failed."<<endl ;
			return JavaPixelEngineHelperInterface::cstring2jstring( env , "" ) ;
		}else{
			stringstream ss ;
			ss<<left<<","<<right<<","<<top<<","<<bottom ;
			return JavaPixelEngineHelperInterface::cstring2jstring( env , ss.str().c_str() ) ;
		}
	}
}


/* 2022-3-23 TileComputeResult 直接使用hseg.tlv裁剪接口，不经过V8和js代码
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    ClipTileComputeResultByHsegTlv
 * Signature: (Lcom/pixelengine/TileComputeResult;[BD)Lcom/pixelengine/TileComputeResult;
 */
JNIEXPORT jobject JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_ClipTileComputeResultByHsegTlv
  (JNIEnv * env , jobject object,
  	jstring javaPEHelperClassName,
  	jobject oldTileComputeResult,
  	jbyteArray hsegtlvdata,
  	jdouble filldata )
{
	jclass	javaTileComputeResultClass = (env)->FindClass("com/pixelengine/TileComputeResult");
	if( javaTileComputeResultClass == NULL )
	{
		printf("Error : not find class of com/pixelengine/TileComputeResult.");
		return NULL ;
	}

	//WHsegTlvObject
	WHsegTlvObject tlv ;
	{
		vector<unsigned char> tlvdata ;
		jbyte* tlvbytedata1 = (jbyte*)env->GetByteArrayElements(hsegtlvdata,0) ;
		jsize  tlvbytelen = env->GetArrayLength(hsegtlvdata) ;
		//copy data
		tlvdata.resize(tlvbytelen) ;
		memcpy( tlvdata.data() , tlvbytedata1 , tlvbytelen ) ;
		env->ReleaseByteArrayElements(hsegtlvdata,tlvbytedata1,0) ;
		string error ;
		bool ok1 = tlv.readFromBinaryData(tlvdata,error) ;
		if( ok1==false ){
			cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ClipTileComputeResultByHsegTlv bad tlv:"<<error<<endl ;
			return NULL ;
		}
	}


	double filldata1 = filldata ;

	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;

	int dataType = 0 ;
	int outType = 0 ;
	int nbands = 0 ;
	int status= 0 ;
	vector<unsigned char> olddata , newdata ;
	int tilez,tiley,tilex ;

	helper.getJavaObjectIntField(oldTileComputeResult,"status",status) ;
	helper.getJavaObjectIntField(oldTileComputeResult,"outType",outType) ;
	helper.getJavaObjectIntField(oldTileComputeResult,"dataType",dataType) ;
	helper.getJavaObjectIntField(oldTileComputeResult,"nbands",nbands) ;
	helper.getJavaObjectIntField(oldTileComputeResult,"z",tilez) ;
	helper.getJavaObjectIntField(oldTileComputeResult,"y",tiley) ;
	helper.getJavaObjectIntField(oldTileComputeResult,"x",tilex) ;
	if( status==0 ){
		helper.getJavaObjectByteArrField(oldTileComputeResult,"binaryData",olddata) ;
		newdata.resize(olddata.size()) ;
		//clip2
		bool clipok = false ;
		PixelEngine pe ;
		if( dataType==1 ){
			clipok = pe.innerCopyRoiData2(
				(unsigned char*)olddata.data() ,
				(unsigned char*)newdata.data(),
				tlv,
				(int)filldata1,
				tilez, tiley, tilex,
				256, 256 , nbands ) ;
		}else if( dataType==2 ){
			clipok = pe.innerCopyRoiData2(
				(unsigned short*)olddata.data() ,
				(unsigned short*)newdata.data(),
				tlv,
				(int)filldata1,
				tilez, tiley, tilex,
				256, 256 , nbands ) ;
		}else if( dataType==3 ){
			clipok = pe.innerCopyRoiData2(
				( short*)olddata.data() ,
				( short*)newdata.data(),
				tlv,
				(int)filldata1,
				tilez, tiley, tilex,
				256, 256 , nbands ) ;
		}else if( dataType==4 ){
			clipok = pe.innerCopyRoiData2(
				(unsigned int*)olddata.data() ,
				(unsigned int*)newdata.data(),
				tlv,
				(int)filldata1,
				tilez, tiley, tilex,
				256, 256 , nbands ) ;
		}else if( dataType==5 ){
			clipok = pe.innerCopyRoiData2(
				(int*)olddata.data() ,
				(int*)newdata.data(),
				tlv,
				(int)filldata1,
				tilez, tiley, tilex,
				256, 256 , nbands ) ;
		}else if( dataType==6 ){
			clipok = pe.innerCopyRoiData2(
				(float*)olddata.data() ,
				(float*)newdata.data(),
				tlv,
				(int)filldata1,
				tilez, tiley, tilex,
				256, 256 , nbands ) ;
		}else if( dataType==7 ){
			clipok = pe.innerCopyRoiData2(
				(double*)olddata.data() ,
				(double*)newdata.data(),
				tlv,
				(int)filldata1,
				tilez, tiley, tilex,
				256, 256 , nbands ) ;
		}
		if( clipok==false ){
			cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ClipTileComputeResultByHsegTlv bad clip."<<endl ;
			return NULL ;
		}
	}


	jobject	newResult = env->AllocObject(javaTileComputeResultClass);
	helper.setJavaObjectIntField(newResult,"status",status) ;//status=0 ok.
	helper.setJavaObjectIntField(newResult,"outType", outType) ;//0-dataset, 1-png
	helper.setJavaObjectIntField(newResult,"dataType", dataType) ;//useful ?
	helper.setJavaObjectIntField(newResult,"width",  256) ;
	helper.setJavaObjectIntField(newResult,"height", 256) ;
	helper.setJavaObjectIntField(newResult,"nbands", nbands) ;//useful ?
	helper.setJavaObjectIntField(newResult,"z", tilez) ;
	helper.setJavaObjectIntField(newResult,"y", tiley) ;
	helper.setJavaObjectIntField(newResult,"x", tilex) ;
	if( status==0 ){
		helper.setJavaObjectByteArrField(newResult,"binaryData", newdata) ;
	}

	return newResult ;

}


/* 2022-3-26 直接对瓦片结果进行统计，不适用v8
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    ComputeStatisticTileComputeResultByHsegTlv
 * Signature: (Ljava/lang/String;Lcom/pixelengine/TileComputeResult;[BDDD)[Lcom/pixelengine/JStatisticData;
 */
JNIEXPORT jobject JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_ComputeStatisticTileComputeResultByHsegTlv
  (
		JNIEnv *env, //jni
		jobject obj, //jni
		jstring javaPEHelperClassName,//javahelperclassname
		jobject tcr, //tilecomputeresult
		jbyteArray hsegtlvdata, //roi tlv
		jdouble filldata,
		jdouble vMinInc,
		jdouble vMaxInc
    )
{
    jclass	javaTileComputeResultClass = (env)->FindClass("com/pixelengine/TileComputeResult");
	if( javaTileComputeResultClass == NULL )
	{
		printf("Error : Java_com_pixelengine_HBasePeHelperCppConnector_ComputeStatisticTileComputeResultByHsegTlv not find class of com/pixelengine/TileComputeResult.");
		return NULL ;
	}

    jclass	jstatisticDataClass = (env)->FindClass("com/pixelengine/JStatisticData");
	if( jstatisticDataClass == NULL )
	{
		printf("Error : Java_com_pixelengine_HBasePeHelperCppConnector_ComputeStatisticTileComputeResultByHsegTlv not find class of com/pixelengine/JStatisticData.");
		return NULL ;
	}


	//WHsegTlvObject
	WHsegTlvObject tlv ;
	{
		vector<unsigned char> tlvdata ;
		jbyte* tlvbytedata1 = (jbyte*)env->GetByteArrayElements(hsegtlvdata,0) ;
		jsize  tlvbytelen = env->GetArrayLength(hsegtlvdata) ;
		//copy data
		tlvdata.resize(tlvbytelen) ;
		memcpy( tlvdata.data() , tlvbytedata1 , tlvbytelen ) ;
		env->ReleaseByteArrayElements(hsegtlvdata,tlvbytedata1,0) ;
		string error ;
		bool ok1 = tlv.readFromBinaryData(tlvdata,error) ;
		if( ok1==false ){
			cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ComputeStatisticTileComputeResultByHsegTlv bad tlv:"<<error<<endl ;
			return NULL ;
		}
	}


	double filldata1 = filldata ;
	double validmin1 = vMinInc;
	double validmax1 = vMaxInc;

	string helperclassname = JavaPixelEngineHelperInterface::jstring2cstring(env,javaPEHelperClassName) ;
	JavaPixelEngineHelperInterface helper(env, helperclassname) ;

	int dataType = 0 ;
	int outType = 0 ;//png or binary
	int nbands = 0 ;
	int status= 0 ;
	vector<unsigned char> tcrdata ;
	int tilez,tiley,tilex ;

	helper.getJavaObjectIntField(tcr,"status",status) ;
	helper.getJavaObjectIntField(tcr,"outType",outType) ;
	helper.getJavaObjectIntField(tcr,"dataType",dataType) ;
	helper.getJavaObjectIntField(tcr,"nbands",nbands) ;
	helper.getJavaObjectIntField(tcr,"z",tilez) ;
	helper.getJavaObjectIntField(tcr,"y",tiley) ;
	helper.getJavaObjectIntField(tcr,"x",tilex) ;

	vector<WStatisticData> statDataResults ;
	if( status==0 ){
		helper.getJavaObjectByteArrField(tcr,"binaryData",tcrdata) ;
		PixelEngine pe ;
		bool statok = false ;
		if( dataType==1 ){
			statok = PixelEngine::computeStatistic<unsigned char>(
                (unsigned char*)tcrdata.data(),
                tlv, filldata1, tilez, tiley, tilex ,256,256, nbands,
                validmin1,validmax1,statDataResults
			) ;
		}else if( dataType==2 ){
			statok = pe.computeStatistic(
                (unsigned short*)tcrdata.data(),
                tlv, filldata1, tilez, tiley, tilex ,256,256, nbands,
                validmin1,validmax1,statDataResults
			) ;
		}else if( dataType==3 ){
			statok = pe.computeStatistic(
                (short*)tcrdata.data(),
                tlv, filldata1, tilez, tiley, tilex ,256,256, nbands,
                validmin1,validmax1,statDataResults
			) ;
		}else if( dataType==4 ){
			statok = pe.computeStatistic(
                (unsigned int*)tcrdata.data(),
                tlv, filldata1, tilez, tiley, tilex ,256,256, nbands,
                validmin1,validmax1,statDataResults
			) ;
		}else if( dataType==5 ){
			statok = pe.computeStatistic(
                (int*)tcrdata.data(),
                tlv, filldata1, tilez, tiley, tilex ,256,256, nbands,
                validmin1,validmax1,statDataResults
			) ;
		}else if( dataType==6 ){
			statok = pe.computeStatistic(
                (float*)tcrdata.data(),
                tlv, filldata1, tilez, tiley, tilex ,256,256, nbands,
                validmin1,validmax1,statDataResults
			) ;
		}else if( dataType==7 ){
			statok = pe.computeStatistic(
                (double*)tcrdata.data(),
                tlv, filldata1, tilez, tiley, tilex ,256,256, nbands,
                validmin1,validmax1,statDataResults
			) ;
		}
		if( statok==false ){
			cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ComputeStatisticTileComputeResultByHsegTlv bad statistic."<<endl ;
			return NULL ;
		}
	}


    // jstatisticDataClass
	jobjectArray outStatDataArray = env->NewObjectArray( statDataResults.size() , jstatisticDataClass ,NULL) ;
	if( outStatDataArray == NULL ){
        cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ComputeStatisticTileComputeResultByHsegTlv bad outStatDataArray."<<endl ;
		return NULL ;
	}
	for( int ib ; ib < statDataResults.size() ; ++ib )
	{
        jobject	jstatdata1 = env->AllocObject(jstatisticDataClass);
        helper.setJavaObjectDoubleField(jstatdata1, "sum" ,         statDataResults[ib].sum ) ;
        helper.setJavaObjectDoubleField(jstatdata1, "sq_sum" ,      statDataResults[ib].sq_sum ) ;
        helper.setJavaObjectDoubleField(jstatdata1, "validCnt" ,    statDataResults[ib].validCnt ) ;
        helper.setJavaObjectDoubleField(jstatdata1, "validMin" ,    statDataResults[ib].validMin ) ;
        helper.setJavaObjectDoubleField(jstatdata1, "validMax" ,    statDataResults[ib].validMax ) ;
        helper.setJavaObjectDoubleField(jstatdata1, "areakm2" ,     statDataResults[ib].areakm2 ) ;
        helper.setJavaObjectDoubleField(jstatdata1, "allCnt" ,      statDataResults[ib].allCnt ) ;
        helper.setJavaObjectDoubleField(jstatdata1, "fillCnt" ,     statDataResults[ib].fillCnt ) ;
        env->SetObjectArrayElement(outStatDataArray , ib , jstatdata1) ;
	}
	return outStatDataArray ;

}




/* 2022-9-27 裁剪二进制瓦片数据，裁剪区外使用filldata填充，不用v8，如果失败返回NULL
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    ClipBinaryTileData
 * Signature: ([BIIIIIII[BD)[B
 */
JNIEXPORT jbyteArray JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_ClipBinaryTileData
  (JNIEnv *env, jobject obj, jstring clsname,
    jbyteArray dataArr,jint datatype,
    jint width,jint height,jint nbands,
    jint z,jint y,jint x,
    jbyteArray tlvdata,jdouble filldata)
{
	//WHsegTlvObject
	JniHelperTools jnitool ;
	WHsegTlvObject tlv ;
	{
		vector<unsigned char> ctlvdata ;
		bool oktlv = jnitool.copyJbyteArray2VectorData(env,tlvdata,ctlvdata) ;
		if( oktlv==false ){
			cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ClipBinaryTileData bad input tlvdata."<<endl ;
			return NULL ;
		}
		string error ;
		bool ok1 = tlv.readFromBinaryData(ctlvdata,error) ;
		if( ok1==false ){
			cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ClipBinaryTileData bad tlv:"<<error<<endl ;
			return NULL ;
		}
	}
	double filldata1 = filldata ;

	int dataType = datatype ;
	int outType =  dataType ;
	vector<unsigned char> olddata , newdata ;
	int tilez=z;
	int tiley=y;
	int tilex=x;
	bool copyok1 = jnitool.copyJbyteArray2VectorData(env,dataArr,olddata);
	if( copyok1==false ){
		cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ClipBinaryTileData copy input dataArr failed."<<endl ;
		return NULL ;
	}

	newdata.resize(olddata.size()) ;
	//clip2
	bool clipok = false ;
	PixelEngine pe ;
	if( dataType==1 ){
		clipok = pe.innerCopyRoiData2(
			(unsigned char*)olddata.data() ,
			(unsigned char*)newdata.data(),
			tlv,
			(int)filldata1,
			tilez, tiley, tilex,
			256, 256 , nbands ) ;
	}else if( dataType==2 ){
		clipok = pe.innerCopyRoiData2(
			(unsigned short*)olddata.data() ,
			(unsigned short*)newdata.data(),
			tlv,
			(int)filldata1,
			tilez, tiley, tilex,
			256, 256 , nbands ) ;
	}else if( dataType==3 ){
		clipok = pe.innerCopyRoiData2(
			( short*)olddata.data() ,
			( short*)newdata.data(),
			tlv,
			(int)filldata1,
			tilez, tiley, tilex,
			256, 256 , nbands ) ;
	}else if( dataType==4 ){
		clipok = pe.innerCopyRoiData2(
			(unsigned int*)olddata.data() ,
			(unsigned int*)newdata.data(),
			tlv,
			(int)filldata1,
			tilez, tiley, tilex,
			256, 256 , nbands ) ;
	}else if( dataType==5 ){
		clipok = pe.innerCopyRoiData2(
			(int*)olddata.data() ,
			(int*)newdata.data(),
			tlv,
			(int)filldata1,
			tilez, tiley, tilex,
			256, 256 , nbands ) ;
	}else if( dataType==6 ){
		clipok = pe.innerCopyRoiData2(
			(float*)olddata.data() ,
			(float*)newdata.data(),
			tlv,
			(int)filldata1,
			tilez, tiley, tilex,
			256, 256 , nbands ) ;
	}else if( dataType==7 ){
		clipok = pe.innerCopyRoiData2(
			(double*)olddata.data() ,
			(double*)newdata.data(),
			tlv,
			(int)filldata1,
			tilez, tiley, tilex,
			256, 256 , nbands ) ;
	}
	if( clipok==false ){
		cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ClipBinaryTileData bad clip."<<endl ;
		return NULL ;
	}
	jbyteArray resArr = jnitool.createJbyteArrayByVectorData(env,newdata);
	if( resArr==NULL){
		cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ClipBinaryTileData bad convert jbyteArray."<<endl ;
		return NULL ;
	}
	return resArr ;
}

/* 2022-9-27 数据使用PeStyle（JSON格式字符串，可以为空PeStyle，空Style使用0-255渲染）渲染RGBA byte 4波段数组，不用v8，如果失败返回NULL
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    RenderTileData2Rgba
 * Signature: ([BIIIILjava/lang/String;)[B
 */
JNIEXPORT jbyteArray JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_RenderTileData2Rgba
  (JNIEnv *env, jobject obj, jstring clsname,
    jbyteArray dataArr,jint datatype,
    jint width,jint height,jint nbands,
    jstring peStyleJsonText)
{
	vector<unsigned char> dataVec,rgbaVec ;
	JniHelperTools jnitool ;
	bool copyok = jnitool.copyJbyteArray2VectorData(env, dataArr , dataVec ) ;
	if( copyok==false ){
		cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_RenderTileData2Rgba copy failed."<<endl;
		return NULL ;
	}

	pe::PeStyle style ;
	string cStyleText = JavaPixelEngineHelperInterface::jstring2cstring(env,peStyleJsonText) ;
	if( cStyleText=="" ){
		style = pe::PeStyle::emptyStyle();
	}else{
		bool styleok = style.loadFromJson(cStyleText);
		if( styleok==false ){
			cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_RenderTileData2Rgba style json bad:"<<cStyleText<<endl ;
			return NULL ;
		}
	}

	string rgbaError;

	PixelEngine pe ;
	pe.RenderData2RgbaByPeStyle(
		dataVec.data() ,//BSQ
        (int)datatype,
        (int)width,
        (int)height,
        (int)nbands,
        style,
        rgbaVec,//BSQ RGBA four bands.
        rgbaError
		) ;

	jbyteArray resArr = jnitool.createJbyteArrayByVectorData(env,rgbaVec);
	if( resArr==NULL){
		cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_RenderTileData2Rgba bad convert jbyteArray."<<endl ;
		return NULL ;
	}
	return resArr ;
	
}


/* 2022-9-27 4波段RGBA byte数组转压缩png二进制数据，不用v8，如果失败返回NULL
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    ConvertRgbaData2PngBinary
 * Signature: ([BII)[B
 */
JNIEXPORT jbyteArray JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_ConvertRgbaData2PngBinary
  (JNIEnv *env, jobject obj, jstring clsname,
    jbyteArray rgbaData,
    jint width,jint height )
{
	JniHelperTools jnitool ;
	vector<unsigned char> rgbaVec, pngVec ;
	bool rgbaok = jnitool.copyJbyteArray2VectorData(env,rgbaData,rgbaVec) ;
	if( rgbaok==false ){
		cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ConvertRgbaData2PngBinary rgbadata bad."<<endl ;
		return NULL ;
	}

	PixelEngine pe ;
	bool pngok = pe.rgbaData2Png(
		rgbaVec ,
		width, 
		height,
		pngVec );
	if( pngok==false ){
		cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ConvertRgbaData2PngBinary convert png bad."<<endl ;
		return NULL ;
	}
	jbyteArray resArr = jnitool.createJbyteArrayByVectorData(env,pngVec);
	if( resArr==NULL){
		cout<<"Java_com_pixelengine_HBasePeHelperCppConnector_ConvertRgbaData2PngBinary bad convert jbyteArray."<<endl ;
		return NULL ;
	}
	return resArr ;

}
