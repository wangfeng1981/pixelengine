/* DO NOT EDIT THIS FILE - it is machine generated */
#include "com_pixelengine_HBasePeHelperCppConnector.h"

#include <string>
#include <vector>
#include <iostream>
#include "lodepng.h"
#include "PixelEngine.h"
#include <random>
#include "../JavaPixelEngineHelperInterface.h"
#include "../wDatasetDatetime.h"
#include "spdlog/spdlog.h"
#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/sinks/basic_file_sink.h"
#include "../ajson5.h"

using namespace std;
using namespace ArduinoJson;





jstring cstring2jstring(JNIEnv *env, 
	const char* str) {
	return env->NewStringUTF(str) ;
}


/*
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    ParseScriptForDsDt
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
{
	"dsdtarr":[] ,
	"error":"",
	"status":0   //0 for good, 1 for error	
}

 */
JNIEXPORT jstring JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_ParseScriptForDsDt
  (JNIEnv * env, jobject object , jstring scriptContent ) 
{
	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_ParseScriptForDsDt()\n") ;
	auto console_logger = spdlog::stdout_color_mt("log");
	spdlog::set_default_logger(console_logger);

	JavaPixelEngineHelperInterface helper ; 
	helper.env = env;

	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;

	string cscriptContent = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;

	vector<wDatasetDatetime> retdsdtvec;
	string errorText;
	bool ok = pe.RunScriptForDatasetDatetimePairs( nullptr ,
		cscriptContent,
		retdsdtvec ,
		errorText) ;
	DynamicJsonBuffer jsonBuffer;
	JsonObject& root = jsonBuffer.createObject();
	if( ok ){
		root["status"] = 0 ;//ok
		root["error"] = "" ;
		JsonArray& dsdtarr = root.createNestedArray("dsdtarr") ;
		for(int ids = 0 ; ids < retdsdtvec.size(); ++ ids ){
			JsonObject& dobj = dsdtarr.createNestedObject() ;
			dobj["ds"] = retdsdtvec[ids].ds ;
			dobj["dt0"] = retdsdtvec[ids].dt0 ;
			dobj["dt1"] = retdsdtvec[ids].dt1 ;
		}
	}else{
		root["status"] = 1 ; 
		root["error"] = errorText ;
		//root["dsdtarr"]
		root.createNestedArray("dsdtarr") ;
	}

	string jsonstr ;
	root.printTo(jsonstr) ;
	jstring jstr = JavaPixelEngineHelperInterface::cstring2jstring(env, jsonstr.c_str() ) ;
	return jstr ;
}

/*
 * Class:     com_pixelengine_HBasePeHelperCppConnector
 * Method:    RunScriptForTileWithoutRender
 * Signature: (Ljava/lang/String;JIII)Lcom/pixelengine/TileComputeResult;
 */
JNIEXPORT jobject JNICALL Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithoutRender
  (JNIEnv * env, jobject object, jstring scriptContent, jlong datetime, jint z, jint y, jint x)
{

	printf("in Java_com_pixelengine_HBasePeHelperCppConnector_RunScriptForTileWithoutRender()\n") ;
	jclass	javaTileComputeResultClass = (env)->FindClass("com/pixelengine/TileComputeResult");
	jobject	javaResult = env->AllocObject(javaTileComputeResultClass);


	JavaPixelEngineHelperInterface helper ; 
	helper.env = env;

	PixelEngine::initV8() ;
	PixelEngine pe ;
	pe.helperPointer = &helper ;

	string cscript = JavaPixelEngineHelperInterface::jstring2cstring(env,scriptContent) ;
	PeTileData retTileData;
	string logStr;

	bool runok = pe.RunScriptForTileWithoutRender(nullptr,
		cscript , 
		datetime , 
		z , y , x , 
		retTileData ,
		logStr ) ;

	if( runok == false ){
		cout<<"run script failed : "<<logStr<<endl;

	}else{
		cout<<"run script ok."<<endl ;
	}


	//bool RunScriptForTileWithoutRender(void* extra, string& scriptContent, int64_t currentDatetime,
	//  int z, int y, int x, PeTileData& tileData , string& logStr);
	
	
	return javaResult ;
	
}





    // const jbyteArray stringJbytes = (jbyteArray) env->CallObjectMethod(jStr, getBytes, env->NewStringUTF("UTF-8"));

    // size_t length = (size_t) env->GetArrayLength(stringJbytes);
    // jbyte* pBytes = env->GetByteArrayElements(stringJbytes, NULL);

    // std::string ret = std::string((char *)pBytes, length);
    // env->ReleaseByteArrayElements(stringJbytes, pBytes, JNI_ABORT);

    // env->DeleteLocalRef(javaHelperObject);
    // env->DeleteLocalRef(javaHelperClass);
